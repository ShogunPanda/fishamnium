#!/usr/bin/env node

const fs = require('fs');
const path = require('path');

const Bookmarks = {
  path: path.resolve(process.env.HOME, '.fishamnium_bookmarks.json'),
  rootPathFormatter: new RegExp(`^(?:${process.env.HOME})`),
  destinationFormatter: new RegExp(`^(?:(?:\\$home)|(?:${process.env.HOME}))`),

  capitalize(input){
    return input
      .split('_')
      .map(s => `${s[0].toUpperCase()}${s.substring(1).toLowerCase()}`)
      .join(' ');
  },

  resolveDestination(bookmark){
    return bookmark.rootPath.replace(/^\$home/, process.env.HOME);
  },

  success(payload){
    if(payload)
      console.log(payload);
  },

  fail(reason){
    console.error(`\x1b[31m${reason}\x1b[39m`);
    process.exitCode = 1;
    return null;
  },

  load(){
    try{
      return JSON.parse(fs.readFileSync(Bookmarks.path, 'utf8'))
        .sort((a, b) => a.bookmark.localeCompare(b.bookmark)); // Sort by name
    }catch(e){
      return Bookmarks.fail(`Cannot load bookmarks file ${Bookmarks.path}.`);
    }
  },

  save(bookmarks){
    try{
      bookmarks = bookmarks.sort((a, b) => a.bookmark.localeCompare(b.bookmark)); // Sort by name
      fs.writeFileSync(Bookmarks.path, JSON.stringify(bookmarks, null, 2), 'utf8');
      Bookmarks.success();
    }catch(e){
      Bookmarks.fail(`Cannot save bookmarks file ${Bookmarks.path}.`);
    }
  },

  show(bookmark = ''){
    const bookmarks = Bookmarks.load();
    if(!bookmarks)
      return null;

    // Validate the argument
    if(!bookmark.length)
      return Bookmarks.fail('Please provide a bookmark name.');

    // Find the bookmark
    const saved = bookmarks.find(b => b.bookmark === bookmark);

    if(!saved)
      return Bookmarks.fail(`The bookmark "${bookmark}" does not exist.`);

    // Show the bookmark
    return Bookmarks.success(Bookmarks.resolveDestination(saved));
  },

  create(bookmark = '', name = ''){
    const bookmarks = Bookmarks.load();

    if(!bookmarks)
      return null;

    // Validate the argument
    if(!bookmark.length)
      return Bookmarks.fail('Please provide a bookmark name.');
    else if(!bookmark.match(/^(?:[a-z0-9-_.:@]+)$/i))
      return Bookmarks.fail('Please use only letters, numbers, and "-", "_", ".", ":" and "@" only.');

    // Check that the bookmark doesn't already exists
    const existing = bookmarks.find(b => b.bookmark === bookmark);
    if(existing)
      return Bookmarks.fail(`The bookmark "${bookmark}" already exists and points to ${Bookmarks.resolveDestination(existing)}.`);

    // Create and save the bookmark
    const rootPath = process.cwd().replace(Bookmarks.rootPathFormatter, '$home');

    // Capitalize the name if nothing was given
    if(!name)
      name = Bookmarks.capitalize(bookmark);

    bookmarks.push({name, bookmark, rootPath, paths: [], group: ''});

    return Bookmarks.save(bookmarks);
  },

  delete(bookmark = ''){
    const bookmarks = Bookmarks.load();
    if(!bookmarks)
      return null;

    // Validate the argument
    if(!bookmark.length)
      return Bookmarks.fail('Please provide a bookmark name.');

    // Find the bookmark
    const bookmarkIndex = bookmarks.findIndex(b => b.bookmark === bookmark);

    if(bookmarkIndex === -1)
      return Bookmarks.fail(`The bookmark "${bookmark}" does not exist.`);

    // Perform deletion and save
    bookmarks.splice(bookmarkIndex, 1);
    return Bookmarks.save(bookmarks);
  },

  list(type){
    const bookmarks = Bookmarks.load();
    let response = '';

    if(!bookmarks)
      return null;
    else if(type === '-n' || type === '--names-only') // Only show names
      response = bookmarks.map(b => b.bookmark).sort().join('\n');
    else if(type === '--autocomplete') // Autocomplete
      response = bookmarks.map(b => `${b.bookmark}\t${b.name}`).sort().join('\n');
    else{
      // Prepare printing
      const maximumLength = Math.max(...bookmarks.map(b => b.bookmark.length));
      const padder = ' '.repeat(maximumLength);

      // Print
      response = bookmarks
        .map(bookmark => {
          const name = (bookmark.bookmark + padder).substring(0, maximumLength); // Pad name
          const destination = bookmark.rootPath.replace(Bookmarks.destinationFormatter, '\x1b[33m$HOME\x1b[39m'); // Replace home folder in destination
          return `\x1b[32m${name}\x1b[39m \u{2192} \x1b[1m${destination}\x1b[22m`;
        })
        .join('\n');
    }

    // Show reply
    return Bookmarks.success(response);
  },

  main(command, ...args){
    switch(command){
      case 'g':
      case 'get':
      case 'show':
      case 'load':
      case 'read':
        Bookmarks.show(args[0]);
        break;
      case 's':
      case 'set':
      case 'save':
      case 'write':
        Bookmarks.create(...args);
        break;
      case 'd':
      case 'delete':
      case 'erase':
      case 'remove':
        Bookmarks.delete(args[0]);
        break;
      case 'l':
      case 'list':
        Bookmarks.list(args[0]);
        break;
      default:
        Bookmarks.fail('Usage: fishamnium_bookmarks s|d|l|get|set|delete|list|load|save|erase|read|write|remove [NAME] [DESCRIPTION]');
        break;
    }
  }
};

Bookmarks.main(...process.argv.slice(2));
