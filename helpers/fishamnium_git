#!/usr/bin/env node

const fs = require("fs");
const path = require("path");
const argsplit = require("argsplit");
const childProcess = require("child_process");

let Git = null;

const Workflow = {
  debug(step){
    console.log(`\x1b[33m\u{22EF} Workflow: ${step}\x1b[39m`);
  },

  start(name, base, {remote}){
    if(!base)
      base = Git.cli.defaultBranch;

    Workflow.debug(`Creating a new branch "${name}" using base branch "${remote}/${base}" ...`);

    // Execute the chain
    return Git.executeChain([
      "fetch",
      `checkout ${base}`,
      `pull ${remote} ${base}`,
      `checkout -b ${name}`
    ]);
  },

  async refresh(current, base, {remote}){
    if(!base)
      base = Git.cli.defaultBranch;

    const internal = current !== null;
    if(!current)
      current = await Git.branchName();

    if(!internal)
      Workflow.debug(`Refreshing current branch "${current}" on top of base branch "${remote}/${base}" ...`);

    // Execute the chain
    return Git.executeChain([
      "fetch",
      `checkout ${base}`,
      `pull ${remote} ${base}`,
      `checkout ${current}`,
      `rebase ${base}`
    ]);
  },

  async finish(deleteAfter, base, {remote, importSource, current}){
    if(!base)
      base = Git.cli.defaultBranch;

    if(!current)
      current = await Git.branchName();

    if(current === base)
      return Git.fail("You are already on the base/destination branch.");

    Workflow.debug(`Merging current branch "${current}" to branch "${remote}/${base}" ...`);
    if(deleteAfter)
      Workflow.debug(`After merging, the new current branch will be "${base}" and the current branch "${current}" will be deleted.`);

    await Workflow.refresh(current, importSource || base, {remote});

    const commands = [
      `checkout ${base}`,
      `merge --no-ff --no-edit ${current}`
    ];

    if(!importSource)
      commands.push(`push ${remote} ${base}`);

    if(deleteAfter)
      commands.push(`branch -D ${current}`);

    return Git.executeChain(commands);
  },

  async fastCommit(name, message, base, {remote}){
    await Workflow.start(name, base, {remote});
    Workflow.debug(`Commiting with message: "${message}" ...`);
    await Git.commitWithTask(true, message, null, {addAll: true});
    await Workflow.finish(true, base, {remote});
  },

  async pullRequest(current, base, {remote}){
    if(!base)
      base = Git.cli.defaultBranch;

    if(!current)
      current = await Git.branchName();

    if(current === base)
      return Git.fail("You are already on the base/destination branch.");

    await Workflow.refresh(current, base, {remote});

    // Push the branch
    const output = await Git.execute(`push -f ${remote} ${current}`, false, false, true);

    // Find the PR url
    const url = output.stderr.trim().split("\n")
      .map(line => {
        line = line.replace("remote: ", "").trim();

        if(line.match(/^(?:To github\.com:(.+)\.git)$/)) // Fix for Github
          line = `https://github.com/${RegExp.$1}/compare/${current}?expand=1`;

        return line;
      })
      .find(l => (
        (l.startsWith("https://gitlab.com/") && l.includes("/merge_requests/new")) || // GitLab
        (l.startsWith("https://github.com/") && l.includes("/compare")) || // GitHub
        (l.includes("/compare/commits?sourceBranch=")) // JIRA
      ));

    Workflow.debug(`The new current branch is now "${base}" and old current branch "${current}" has been deleted.`);
    await Git.executeChain([`checkout ${base}`, `branch -D ${current}`]);

    if(!url)
      return Git.fail("Could not detect a Pull Request creation URL. Please take care of this last step manually.", false);

    Workflow.debug(`Opening URL ${url} to finalize the Pull Request creation ...`);
    childProcess.exec(`open "${url}"`);
    return true;
  },

  async fastPullRequest(name, message, base, {remote}){
    await Workflow.start(name, base, {remote});
    Workflow.debug(`Commiting with message: "${message}" ...`);
    await Git.commitWithTask(true, message, null, {addAll: true});
    await Workflow.pullRequest(name, base, {remote});
  },

  async releaseTag(version, base, {prefix, remote}){
    if(!base)
      base = Git.cli.defaultBranch;

    const current = await Git.branchName();
    const name = `${prefix}${version}`;

    Workflow.debug(`Creating release "${name}" and pushing to the remote "${remote}"...`);
    await Workflow.start(name, base, {remote});
    return Git.executeChain([
      `push -f ${remote} ${name}`,
      `checkout ${current}`,
      `branch -D ${name}`
    ]);
  },

  async import(source, destination, {temporary, remote}){
    if(!destination)
      destination = await Git.branchName();

    if(!temporary)
      temporary = `import-${source}`;

    await Git.delete(false, temporary, {remote});
    await Workflow.start(temporary, source, {remote});
    return Workflow.finish(true, destination, {remote, importSource: source, current: temporary});
  },

  releaseStart(name, version, {prefix, remote}){
    const base = `${prefix}${version}`;
    return Workflow.start(name, base, {remote});
  },

  releaseRefresh(version, {prefix, remote}){
    const base = `${prefix}${version}`;
    return Workflow.refresh(null, base, {remote});
  },

  releaseFinish(deleteAfter, version, {prefix, remote}){
    const base = `${prefix}${version}`;
    return Workflow.finish(deleteAfter, base, {remote});
  },

  releaseImport(version, destination, {prefix, temporary, remote}){
    const source = `${prefix}${version}`;
    return Workflow.import(source, destination, {temporary, remote});
  },

  releaseDelete(version, {prefix, remote}){
    const base = `${prefix}${version}`;
    return Git.delete(true, base, {remote});
  }
};

Git = {
  cli: require("commander"),

  taskMatcher: new RegExp(
    "^(?:" +
    "(?:((?:[a-z#]+-)?\\d+)-{1,2})?" + // Task in the prefix
    "(?:.+?)" + // Task subject
    "(?:-{1,2}((?:[a-z#]+-)?\\d+))?" + // Task in the suffix
    ")$",
    "i"
  ),

  /* eslint-disable camelcase */
  commands: {
    is_repository: "isRepository",
    is_dirty: "isDirty",
    remotes: "showRemotes"
  },
  /* eslint-enable camelcase */

  capitalize(input){
    return input
      .split("_")
      .map(s => `${s[0].toUpperCase()}${s.substring(1).toLowerCase()}`)
      .join(" ");
  },

  complete(errorCode = null){
    if(Git.cli.quiet)
      return;

    if(errorCode)
      console.log(`\x1b[31m\u{2717} One of operations failed with code ${errorCode}.\x1b[39m`);
    else
      console.log("\x1b[32m\u{2713} All operations completed successfully!\x1b[39m");

    process.exit(errorCode || 0); // eslint-disable-line no-process-exit
  },

  fail(reason, fatal = true){
    console.error(`\x1b[31m${reason}\x1b[39m`);

    if(fatal)
      process.exit(1); // eslint-disable-line no-process-exit

    return null;
  },

  loadConfiguration(cli){
    try{
      Object.assign(cli, require(path.resolve(process.cwd(), ".fishamnium_git.json")));
    }catch(e){
      // No-op
    }

    // Environment variables always overrides configuration file
    cli.defaultPrefix = process.env.GIT_DEFAULT_PREFIX || "release-";
    cli.defaultBranch = process.env.GIT_DEFAULT_BRANCH || "development";
    cli.defaultRemote = process.env.GIT_DEFAULT_REMOTE || "origin";
    cli.openPath = process.env.OPEN || "/usr/bin/open";
    cli.prependTask = process.env.GIT_TASK_PREPEND === "true";
    cli.quiet = process.env.QUIET === "true";
    cli.debug = process.env.DEBUG === "true";
  },

  execute(args, internal = false, standalone = false, completeReturn = false){
    return new Promise((resolve, reject) => {
      console.log(`\x1b[33m\u{22EF} Executing: git ${args}\x1b[39m`);
      const git = childProcess.spawn("git", argsplit(args), {stdio: completeReturn ? "pipe" : "inherit"});

      let stdout = "";
      let stderr = "";

      if(completeReturn){
        git.stdout.on("data", data => {
          process.stdout.write(data);
          stdout += data.toString("utf8");
        });

        git.stderr.on("data", data => {
          process.stderr.write(data);
          stderr += data.toString("utf8");
        });
      }

      git.on("close", code => {
        if(!internal)
          console.log(`${code !== 0 ? "\x1b[31m\u{2717}" : "\x1b[32m\u{2713}"} Exited with status ${code}.\x1b[39m`);

        process.exitCode = code;

        const rv = completeReturn ? {code, stdout, stderr} : code;
        return standalone || code === 0 ? resolve(rv) : reject(rv);
      });
    });
  },

  async executeChain(commands){
    try{
      for(const command of commands)
        await Git.execute(command);
    }catch(errorCode){
      Git.complete(errorCode);
    }
  },

  executeInternal(...args){
    return new Promise(resolve => {
      childProcess.exec(`git ${args}`, (error, stdout, stderr) => resolve({status: error ? error.code : 0, stdout, stderr}));
    });
  },

  performAction(cli, action, ...args){
    return async (...commandArgs) => {
      // Check that we are in a GIT repository
      const command = commandArgs.pop();
      if(!["is_repository", "summary"].includes(command._name) && !await Git.isRepository())
        return false;

      // Normalize arguments
      if(!Array.isArray(args))
        args = [args];
      if(!Array.isArray(commandArgs))
        commandArgs = [commandArgs];

      // Perform the action
      await action(...args, ...commandArgs, command);
      return true;
    };
  },

  async isRepository(standalone = false, fatal = true){
    // Execute command
    const result = await Git.executeInternal("rev-parse --is-inside-work-tree");
    const inside = result.status === 0;

    // Return output
    if(standalone)
      return console.log(inside);

    return inside || (fatal ? Git.fail("You're not inside a git repository.") : false);
  },

  async isDirty(standalone = false){
    // Execute command
    const result = await Git.executeInternal("status -s");
    const dirty = result.stdout.length !== 0;

    // Return output
    if(standalone)
      return console.log(dirty);

    return dirty;
  },

  async remotes(){
    // Execute command
    const result = await Git.executeInternal("remote -v");

    // Parse output
    const remotes = result.stdout.trim().split("\n").reduce((accu, line) => {
      const [name, url, type] = line.split(/\s+/);

      // Add the remote
      if(!accu[name])
        accu[name] = {};
      accu[name][type.replace(/[()]/g, "")] = url;

      // Simplify output
      if(accu[name].fetch === accu[name].push)
        accu[name] = accu[name].fetch;

      return accu;
    }, {});

    // Show as JSON
    return console.log(JSON.stringify(remotes, null, 2));
  },

  async branchName(standalone = false, short = true){
    // Execute some commands to get the name
    let result = await Git.executeInternal("symbolic-ref HEAD");

    if(result.status !== 0)
      result = await Git.executeInternal("rev-parse --short HEAD");

    // Check results
    if(result.status !== 0 && !standalone)
      return Git.fail("Cannot get git branch name.");

    // Get the name and shorten it if needed
    let name = result.stdout.trim();

    if(short)
      name = name.replace("refs/heads/", "");

    // Show output
    return standalone ? console.log(name) : name;
  },

  async sha(short = false, quiet = false){
    // Execute command
    const result = await Git.executeInternal(`rev-parse ${short ? "--short" : ""} HEAD`);

    // Return output
    if(result.status !== 0)
      return Git.fail(quiet ? null : "Cannot get git SHA.");

    return result.stdout.trim();
  },

  async summary(){
    if(!await Git.isRepository(false, false))
      return null;

    const branch = await Git.branchName();
    const sha = await Git.sha(true);
    const dirty = await Git.isDirty();

    return console.log([branch, sha, dirty].join(" "));
  },

  async task(standalone = false){
    let task = "";

    // Get the task name
    const bn = await Git.branchName(false);
    const taskToken = bn.split("/").pop();
    const mo = taskToken.match(Git.taskMatcher);

    // Find the task portion
    if(mo)
      task = mo[1] || mo[2];

    // Return output
    if(standalone)
      return task ? console.log(task) : null;

    return task;
  },

  async commitWithTask(all, message, task, {addAll}){
    // Resolve the task name if needed and adjust message
    if(!task)
      task = await Git.task();

    if(task)
      message = Git.cli.prependTask ? `[#${task}] ${message}` : `${message} [#${task}]`;

    // Write the commit message to a file
    const commitPath = `/tmp/fishamnium-git-commit-${new Date().getTime()}.txt`;
    fs.writeFileSync(commitPath, message, "utf8");
    // Perform the command
    await Git.executeChain([
      "add -A",
      `commit ${addAll ? "-a" : ""} -F ${commitPath}`
    ]);

    fs.unlinkSync(commitPath);
    return true;
  },

  reset(){
    return Git.executeChain(["reset --hard", "clean -f"]);
  },

  async cleanup(){
    // Get branches
    const result = await Git.executeInternal("branch --merged");

    if(result.status !== 0)
      return Git.fail("Cannot get branches.");

    // Filter branches
    const filteredBranch = ["master", Git.cli.defaultBranch, await Git.branchName()];
    const branches = result.stdout.trim().split("\n").map(b => b.replace(/^\s*\*/, "").trim()).filter(b => !filteredBranch.includes(b));

    if(!branches.length)
      return null;

    // Perform command
    try{
      return Git.execute(`branch -D ${branches.join(" ")}`, false, true);
    }catch(errorCode){
      return Git.complete(errorCode);
    }
  },

  async update(branch, {remote}){
    if(!branch)
      branch = Git.cli.defaultBranch;
    if(!remote)
      remote = Git.cli.defaultRemote;

    try{
      await Git.execute("fetch", false, true);
      await Git.execute(`pull ${remote} ${branch}`, false, true);
      return true;
    }catch(errorCode){
      return Git.complete(errorCode);
    }
  },

  async delete(standalone, branches, {remote}){
    if(!Array.isArray(branches))
      branches = [branches];

    if(!branches.length)
      return null;

    try{
      await Git.execute(`branch -D ${branches.join(" ")}`, false, true);
      await Git.execute(`push ${remote} ${branches.map(b => `:${b}`).join(" ")}`, false, true);
      return true;
    }catch(errorCode){
      return Git.complete(errorCode);
    }
  },

  addReadOnlyCommands(cli){
    cli.command("autocomplete").description("Generates autocompletion for fish shell.").action(Git.performAction(cli, Git.autocomplete));
    cli.command("is_repository").description("Check if the current directory is a GIT repository.").action(Git.performAction(cli, Git.isRepository, true));
    cli.command("is_dirty").description("Check if the current GIT repository has uncommitted changes.").action(Git.performAction(cli, Git.isDirty, true));
    cli.command("remotes").description("Show GIT remotes.").action(Git.performAction(cli, Git.remotes));
    cli.command("full_branch_name").description("Get the full current branch name.").alias("fbn").action(Git.performAction(cli, Git.branchName, true, false));
    cli.command("branch_name").description("Get the current branch name.").alias("bn").action(Git.performAction(cli, Git.branchName, true));
    cli.command("full_sha").description("Get the full current GIT SHA.").action(Git.performAction(cli, Git.sha, false, true));
    cli.command("sha").description("Get the current GIT SHA.").action(Git.performAction(cli, Git.showRemotes, true, true));
    cli.command("task").description("Get the current task name from the branch name.").alias("t").action(Git.performAction(cli, Git.task, true));
    cli.command("summary").description("Get a summary of current GIT repository branch, SHA and dirty status.").action(Git.performAction(cli, Git.summary));
  },

  addWriteCommands(cli){
    cli.command("commit_with_task <message> [task]").alias("ct")
      .description("Commit changes including the task name.")
      .action(Git.performAction(cli, Git.commitWithTask, false));

    cli.command("commit_all_with_task <message> [task]").alias("cat")
      .option("-a,--add-all", "Add all files before commiting.")
      .description("Commit all changes including the task name.")
      .action(Git.performAction(cli, Git.commitWithTask, true));

    cli.command("reset")
      .description("Reset all uncommitted changes.")
      .action(Git.performAction(cli, Git.reset));

    cli.command("cleanup")
      .description("Deletes all non default branches.")
      .action(Git.performAction(cli, Git.cleanup));

    cli.command("update [branch]").alias("u")
      .description("Fetch from remote and pulls a a branch.")
      .action(Git.performAction(cli, Git.update));

    cli.command("delete <branch...>").alias("d")
      .option("-r,--remote <REMOTE>", "The remote to act on.", cli.defaultRemote)
      .description("Deletes one or more branch both locally and on a remote.")
      .action(Git.performAction(cli, Git.delete, true));

    cli.command("start <branch> [base]").alias("s")
      .option("-r,--remote <REMOTE>", "The remote to act on.", cli.defaultRemote)
      .description("Starts a new branch out of the base one.")
      .action(Git.performAction(cli, Workflow.start));

    cli.command("refresh [base]").alias("r")
      .option("-r,--remote <REMOTE>", "The remote to act on.", cli.defaultRemote)
      .description("Rebases the current branch on top of an existing remote branch.")
      .action(Git.performAction(cli, Workflow.refresh, null));

    cli.command("finish [base]").alias("f")
      .option("-r,--remote <REMOTE>", "The remote to act on.", cli.defaultRemote)
      .description("Merges a branch back to its base remote branch.")
      .action(Git.performAction(cli, Workflow.finish, false));

    cli.command("full_finish [base]").alias("ff")
      .option("-r,--remote <REMOTE>", "The remote to act on.", cli.defaultRemote)
      .description("Merges a branch back to its base remote branch and then deletes the local copy.")
      .action(Git.performAction(cli, Workflow.finish, true));

    cli.command("fast_commit <name> <message> [base]").alias("fc")
      .option("-r,--remote <REMOTE>", "The remote to act on.", cli.defaultRemote)
      .description("Creates a local branch, commit changes and then merges it back to the base branch.")
      .action(Git.performAction(cli, Workflow.fastCommit));

    cli.command("pull_request [base]").alias("pr")
      .option("-r,--remote <REMOTE>", "The remote to act on.", cli.defaultRemote)
      .description("Sends a Pull Request and deletes the local branch.")
      .action(Git.performAction(cli, Workflow.pullRequest, null));

    cli.command("fast_pull_request <name> <message> [base]").alias("fpr")
      .option("-r,--remote <REMOTE>", "The remote to act on.", cli.defaultRemote)
      .description("Creates a local branch, commit changes and then sends a Pull Request, deleting the local branch at the end.")
      .action(Git.performAction(cli, Workflow.fastPullRequest));

    cli.command("release <version> [base]").alias("rt")
      .option("-p,--prefix <PREFIX>", "The prefix to use.", cli.defaultPrefix)
      .option("-r,--remote <REMOTE>", "The remote to act on.", cli.defaultRemote)
      .description("Tags and pushes a new release branch out of the base one.")
      .action(Git.performAction(cli, Workflow.releaseTag));

    cli.command("import <source> [destination]").alias("i")
      .option("-t,--temporary <TEMPORARY>", "Name of the temporary branch.")
      .option("-r,--remote <REMOTE>", "The remote to act on.", cli.defaultRemote)
      .description("Imports latest changes to a local branch on top of an existing remote branch.")
      .action(Git.performAction(cli, Workflow.import));

    cli.command("start_from_release <branch> <version>").alias("rs")
      .option("-p,--prefix <PREFIX>", "The prefix to use.", cli.defaultPrefix)
      .option("-r,--remote <REMOTE>", "The remote to act on.", cli.defaultRemote)
      .description("Starts a new branch out of a remote release branch.")
      .action(Git.performAction(cli, Workflow.releaseStart));

    cli.command("refresh_from_release <version>").alias("rr")
      .option("-p,--prefix <PREFIX>", "The prefix to use.", cli.defaultPrefix)
      .option("-r,--remote <REMOTE>", "The remote to act on.", cli.defaultRemote)
      .description("Rebases the current branch on top of an existing remote release branch.")
      .action(Git.performAction(cli, Workflow.releaseRefresh));

    cli.command("finish_to_release <version>").alias("rf")
      .option("-p,--prefix <PREFIX>", "The prefix to use.", cli.defaultPrefix)
      .option("-r,--remote <REMOTE>", "The remote to act on.", cli.defaultRemote)
      .description("Merges a branch back to its base remote release branch.")
      .action(Git.performAction(cli, Workflow.releaseFinish, false));

    cli.command("full_finish_to_release <version>").alias("rff")
      .option("-p,--prefix <PREFIX>", "The prefix to use.", cli.defaultPrefix)
      .option("-r,--remote <REMOTE>", "The remote to act on.", cli.defaultRemote)
      .description("Merges a branch back to its base remote release branch and then deletes the local copy.")
      .action(Git.performAction(cli, Workflow.releaseFinish, true));

    cli.command("import_release <version> [destination]").alias("ri")
      .option("-p,--prefix <PREFIX>", "The prefix to use.", cli.defaultPrefix)
      .option("-t,--temporary <TEMPORARY>", "Name of the temporary branch.")
      .option("-r,--remote <REMOTE>", "The remote to act on.", cli.defaultRemote)
      .description("Imports latest changes to a local branch on top of an existing remote release branch.")
      .action(Git.performAction(cli, Workflow.releaseImport));

    cli.command("delete_release <version>").alias("rd")
      .option("-p,--prefix <PREFIX>", "The prefix to use.", cli.defaultPrefix)
      .option("-r,--remote <REMOTE>", "The remote to act on.", cli.defaultRemote)
      .description("Deletes a release branch locally and remotely.")
      .action(Git.performAction(cli, Workflow.releaseDelete));
  },

  main(){
    const cli = Git.cli;
    cli
      .description("")
      .usage("fishamnium_git COMMAND [ARGS...]");

    Git.loadConfiguration(cli);
    Git.addReadOnlyCommands(cli);
    Git.addWriteCommands(cli);

    return cli.parse(process.argv);
  }
};

if(!process.env.FISHAMNIMUM_GENERATING_AUTOCOMPLETE)
  Git.main();

module.exports = Git;
